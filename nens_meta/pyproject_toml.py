"""Purpose: read and manage the pyproject.toml config file
"""
import logging
from pathlib import Path

import tomlkit
from tomlkit.items import Table
from tomlkit.toml_document import TOMLDocument

from nens_meta import utils

FILENAME = "pyproject.toml"

logger = logging.getLogger(__name__)


def pyproject_toml_file(project: Path) -> Path:
    return project / FILENAME


def create_if_missing(project: Path):
    if not pyproject_toml_file(project).exists():
        pyproject_toml_file(project).write_text("# Initially generated by nens-meta\n")
        logger.info("Created empty pyproject.toml")


class PyprojectToml:
    """Wrapper around a project's pyproject.toml"""

    _project: Path
    _config_file: Path
    _contents: tomlkit.TOMLDocument
    _options: dict

    def __init__(self, project: Path, options: dict):
        self._project = project
        self._config_file = pyproject_toml_file(project)
        self._options = options
        self._contents = self.read()

    def read(self) -> tomlkit.TOMLDocument:
        return tomlkit.parse(self._config_file.read_text())

    def write(self):
        target_name = FILENAME
        if self._options.get("leave_alone"):
            logger.warning(f"Leaving {target_name} alone")
            target_name += ".suggestion"
        target = self._project / target_name
        utils.write_if_changed(target, tomlkit.dumps(self._contents))

    def get_or_create_section(self, name: str) -> Table:
        *super_tables, section_name = name.split(".")
        current_container: TOMLDocument | Table = self._contents
        for super_table in super_tables:
            if super_table not in current_container:  # type: ignore
                current_container.append(
                    super_table, tomlkit.table(is_super_table=True)
                )  # type: ignore
                logger.debug(f"Created section parent {super_table} for {name}")
            current_container = current_container[super_table]  # type: ignore

        if section_name not in current_container:
            current_container.append(section_name, tomlkit.table())
            logger.debug(f"Created section {name}")
        section: Table = current_container[section_name]  # type: ignore
        return section

    def update(self):  # pragma: no cover
        """Update the pyproject.toml file

        `options` is the combined contents of the [meta] and [pyprojecttoml] config
        sections.
        """

        # Naming convention: the "ensure_" methods mostly take complete ownership over a
        # section, the "adjust_" methods mostly leave everything intact and only changes
        # what's necessary.
        self.ensure_build_system()
        self.adjust_project()
        self.ensure_setuptools()
        self.ensure_pytest()
        self.ensure_coverage()
        self.ensure_ruff()
        self.adjust_zestreleaser()
        self.adjust_pyright()

    def ensure_build_system(self):
        section = self.get_or_create_section("build-system")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        section["requires"] = ["setuptools>=69"]

    def adjust_project(self):
        section = self.get_or_create_section("project")
        section["name"] = self._options["project_name"]
        section["name"].comment("Set by nens-meta")
        section["dynamic"] = ["version"]
        section["dynamic"].comment("Set by nens-meta")

        suggestions = {
            "requires-python": ">=3.11",
            "dependencies": [],
            "description": "I really need to set this",
            "authors": [],
            "readme": "README.md",
        }
        for suggestion in suggestions:
            if suggestion not in section:
                section[suggestion] = suggestions[suggestion]
                section[suggestion].comment("Suggested by nens-meta")

        section = self.get_or_create_section("project.optional-dependencies")
        if "test" not in section:
            section["test"] = []
        test_dependencies: list = section["test"]  # type ignore
        if "pytest" not in test_dependencies:
            test_dependencies.append("pytest")
            section["test"].comment("pytest added by nens-meta")

    @property
    def package_name(self) -> str:
        name = self._options.get("package_name")
        if not name:
            logger.error("package_name not set in `.nens.toml` [meta]")
            name = "not_set"
        if not (self._project / name).exists():
            logger.error(f"Python package {name} doesn't exist in the current project")
        return name

    def ensure_setuptools(self):
        section = self.get_or_create_section("tool.setuptools")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        # TODO: optional extra packages
        section["packages"] = [self.package_name]
        section["zip-safe"] = False

        section = self.get_or_create_section("tool.setuptools.dynamic")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        version_data = tomlkit.inline_table()
        version_data.update({"attr": f"{self.package_name}.__version__"})
        section["version"] = version_data
        init_file = self._project / self.package_name / "__init__.py"
        if init_file.exists():
            if "__version__" not in init_file.read_text():
                logger.error(f"__version__ not set in {init_file}, add it there")
        else:
            logger.error(f"{init_file} doesn't exist, add __version__ in there")

    def ensure_pytest(self):
        section = self.get_or_create_section("tool.pytest.ini_options")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        section["log_level"] = "DEBUG"
        section["testpaths"] = [self.package_name]  # TODO: optional extra packages

    def ensure_coverage(self):
        section = self.get_or_create_section("tool.coverage.run")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        section["source"] = [self.package_name]  # TODO: optional extra packages

        section = self.get_or_create_section("tool.coverage.report")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        section["show_missing"] = True
        section["skip_empty"] = True

    def ensure_ruff(self):
        section = self.get_or_create_section("tool.ruff")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        section["target-version"] = "py38"
        section["target-version"].comment("Set by nens-meta")
        # TODO use minumum python version setting

        section = self.get_or_create_section("tool.ruff.lint")
        section.clear()
        section.comment("Whole section managed by nens-meta")
        # Default select: ["E4", "E7", "E9", "F"]
        # select = ["E4", "E7", "E9", "F", "I", "UP", "C901"]
        section["select"] = ["E4", "E7", "E9", "F"]

    def adjust_pyright(self):
        section = self.get_or_create_section("tool.pyright")
        section["include"] = [self.package_name]  # TODO: optional extra packages
        section["include"].comment("Set by nens-meta")
        section["venvPath"] = "."
        section["venvPath"].comment("Set by nens-meta")
        section["venv"] = "venv"
        section["venv"].comment("Set by nens-meta")

    def adjust_zestreleaser(self):
        section = self.get_or_create_section("tool.zest-releaser")
        if "release" not in section:
            section["release"] = False
            section.comment("Suggested by nens-meta, adjust from setup.cfg if needed")

    def move_outdated_files(self):
        """There are various old config files that have to be taken care off

        They shouldn't exist anymore as they can disturb our pyproject.toml
        configuration. But sometimes you need to copy over data (like from the
        setup.py), so they're best moved aside with a postfix.
        """
        for source_name in [".flake8", "setup.py", "setup.cfg", ".coveragerc"]:
            target_name = source_name + ".outdated"
            source = self._project / source_name
            if not source.exists():
                continue
            target = self._project / target_name
            if target.exists():
                target.unlink()
                logger.debug(f"Removed existing {target}")
            source.rename(target)
            logger.info(f"{source} is no longer needed, moved it to {target}")
