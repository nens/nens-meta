"""Purpose: read and manage the .nens.toml config file
"""
import logging
from functools import cached_property
from pathlib import Path

import tomlkit

from nens_meta import __version__, utils

META_FILENAME = ".nens.toml"
KNOWN_SECTIONS: dict[str, dict[str, str]] = {}
# First key is the section name, the second key/value pair is the variable name and the
# explanation.
KNOWN_SECTIONS["meta"] = {
    "version": "Version used to generate the config",
}
KNOWN_SECTIONS["editorconfig"] = {
    "extra_lines": "Extra content at the end of .editorconfig",
}
KNOWN_SECTIONS["tox"] = {
    "minimum_coverage": "Minimum code coverage percentage",
}
KNOWN_SECTIONS["pre-commit-config"] = {
    "extra_lines": "Extra content at the end of the file (watch the indentation)",
}
logger = logging.getLogger(__name__)


def nens_toml_file(project: Path) -> Path:
    return project / META_FILENAME


def create_if_missing(project: Path):
    assert not nens_toml_file(project).exists()
    nens_toml_file(project).write_text("# Initially generated by nens-meta\n")


class MissingDocumentationError(Exception):
    pass


class OurConfig:
    """Wrapper around a project's .nens.toml

    See https://tomlkit.readthedocs.io/en/latest/quickstart/
    """

    _config_file: Path
    _contents: tomlkit.TOMLDocument
    _project: Path

    def __init__(self, project: Path):
        self._project = project
        self._config_file = nens_toml_file(project)
        self._contents = self.read()

    def read(self) -> tomlkit.TOMLDocument:
        return tomlkit.parse(self._config_file.read_text())

    def write(self):
        utils.write_if_changed(self._config_file, tomlkit.dumps(self._contents))

    @cached_property
    def global_options(self) -> dict:
        """Return detected options that will be added to every section"""
        options = {}
        options["is_python_project"] = utils.is_python_project(self._project)
        options["our_version"] = __version__
        # TODO: document this.
        return options

    def section_options(self, section_name: str) -> dict:
        """Return all options configured in a given section

        Later on: perhaps do some filtering on known ones? And add defaults for missing
        ones?

        """
        if section_name not in KNOWN_SECTIONS:
            # Force ourselves to document our stuff!
            raise MissingDocumentationError(
                f"Section {section_name} not documented in nens-meta"
            )
        section = self._contents.get(section_name)
        options: dict[str, str] = {}
        if section:
            for key in KNOWN_SECTIONS[section_name]:
                options[key] = section.get(key, "")  # Default is an empty string.
        else:
            logger.debug(
                f"Extra configuration for [{section_name}] not found in .nens.toml"
            )
        options.update(self.global_options)
        return options
